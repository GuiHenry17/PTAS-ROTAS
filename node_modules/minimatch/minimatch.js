ta. ========",
  "Type_reference_directive_0_was_successfully_resolved_to_1_primary_Colon_2_6119": "======== La direttiva '{0}' del riferimento al tipo è stata risolta in '{1}'. Primaria: {2}. ========",
  "Type_reference_directive_0_was_successfully_resolved_to_1_with_Package_ID_2_primary_Colon_3_6219": "======== La direttiva '{0}' del riferimento al tipo è stata risolta in '{1}' con ID pacchetto ID '{2}'. Primaria: {3}. ========",
  "Type_satisfaction_expressions_can_only_be_used_in_TypeScript_files_8037": "Le espressioni di soddisfazione del tipo possono essere usate solo nei file TypeScript.",
  "Types_cannot_appear_in_export_declarations_in_JavaScript_files_18043": "I tipi non possono essere visualizzati nelle dichiarazioni di esportazione nei file JavaScript.",
  "Types_have_separate_declarations_of_a_private_property_0_2442": "I tipi contengono dichiarazioni separate di una proprietà privata '{0}'.",
  "Types_of_construct_signatures_are_incompatible_2419": "I tipi delle firme del costrutto sono incompatibili.",
  "Types_of_parameters_0_and_1_are_incompatible_2328": "I tipi dei parametri '{0}' e '{1}' sono incompatibili.",
  "Types_of_property_0_are_incompatible_2326": "I tipi della proprietà '{0}' sono incompatibili.",
  "Unable_to_open_file_0_6050": "Non è possibile aprire il file '{0}'.",
  "Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression_1238": "Non è possibile risolvere la firma dell'espressione Decorator della classe quando è chiamata come espressione.",
  "Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression_1241": "Non è possibile risolvere la firma dell'espressione Decorator del metodo quando è chiamata come espressione.",
  "Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression_1239": "Non è possibile risolvere la firma dell'espressione Decorator del parametro quando è chiamata come espressione.",
  "Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression_1240": "Non è possibile risolvere la firma dell'espressione Decorator della proprietà quando è chiamata come espressione.",
  "Unexpected_end_of_text_1126": "Fine del testo imprevista.",
  "Unexpected_keyword_or_identifier_1434": "Parola chiave o identificatore imprevisti.",
  "Unexpected_token_1012": "Token imprevisto.",
  "Unexpected_token_A_constructor_method_accessor_or_property_was_expected_1068": "Token imprevisto. È previsto un costruttore, un metodo, una funzione di accesso o una proprietà.",
  "Unexpected_token_A_type_parameter_name_was_expected_without_curly_braces_1069": "Token imprevisto. Sono previsti nomi di parametro senza parentesi graffe.",
  "Unexpected_token_Did_you_mean_or_gt_1382": "Token imprevisto. Si intendeva `{'>'}` o `>`?",
  "Unexpected_token_Did_you_mean_or_rbrace_1381": "Token imprevisto. Si intendeva `{'}'}` o `&rbrace;`?",
  "Unexpected_token_expected_1179": "Token imprevisto. È previsto '{'.",
  "Unknown_build_option_0_5072": "L'opzione di compilazione '{0}' è sconosciuta.",
  "Unknown_build_option_0_Did_you_mean_1_5077": "L'opzione di compilazione '{0}' è sconosciuta. Si intendeva '{1}'?",
  "Unknown_compiler_option_0_5023": "Opzione del compilatore sconosciuta: '{0}'.",
  "Unknown_compiler_option_0_Did_you_mean_1_5025": "L'opzione '{0}' del compilatore è sconosciuta. Si intendeva '{1}'?",
  "Unknown_keyword_or_identifier_Did_you_mean_0_1435": "Parola chiave o identificatore sconosciuti. Intendevi '{0}'?",
  "Unknown_option_excludes_Did_you_mean_exclude_6114": "L'opzione 'excludes' è sconosciuta. Si intendeva 'exclude'?",
  "Unknown_type_acquisition_option_0_17010": "L'opzione '{0}' relativa all'acquisizione del tipo è sconosciuta.",
  "Unknown_type_acquisition_option_0_Did_you_mean_1_17018": "L'opzione di acquisizione del tipo '{0}' è sconosciuta. Si intendeva '{1}'?",
  "Unknown_watch_option_0_5078": "L'opzione '{0}' dell'espressione di controllo è sconosciuta.",
  "Unknown_watch_option_0_Did_you_mean_1_5079": "L'opzione '{0}' dell'espressione di controllo è sconosciuta. Si intendeva '{1}'?",
  "Unreachable_code_detected_7027": "È stato rilevato codice non raggiungibile.",
  "Unterminated_Unicode_escape_sequence_1199": "Sequenza di escape Unicode senza terminazione.",
  "Unterminated_quoted_string_in_response_file_0_6045": "Stringa tra virgolette senza terminazione nel file di risposta '{0}'.",
  "Unterminated_regular_expression_literal_1161": "Valore letterale di espressione regolare senza terminazione.",
  "Unterminated_string_literal_1002": "Valore letterale stringa senza terminazione.",
  "Unterminated_template_literal_1160": "Valore letterale di modello senza terminazione.",
  "Untyped_function_calls_may_not_accept_type_arguments_2347": "Le chiamate di funzione non tipizzate potrebbero non accettare argomenti tipo.",
  "Unused_label_7028": "Etichetta non usata.",
  "Unused_ts_expect_error_directive_2578": "Direttiva '@ts-expect-error' non usata.",
  "Update_import_from_0_90058": "Aggiornare l'importazione da \"{0}\"",
  "Updating_output_of_project_0_6373": "Aggiornamento dell'output del progetto '{0}'...",
  "Updating_output_timestamps_of_project_0_6359": "Aggiornamento dei timestamp di output del progetto '{0}'...",
  "Updating_unchanged_output_timestamps_of_project_0_6371": "Aggiornamento dei timestamp di output non modificati del progetto '{0}'...",
  "Use_0_95174": "Usa `{0}`.",
  "Use_Number_isNaN_in_all_conditions_95175": "Usare 'Number.isNaN' in tutte le condizioni.",
  "Use_element_access_for_0_95145": "Usare l'accesso agli elementi per '{0}'",
  "Use_element_access_for_all_undeclared_properties_95146": "Usare l'accesso agli elementi per tutte le proprietà non dichiarate.",
  "Use_synthetic_default_member_95016": "Usare il membro 'default' sintetico.",
  "Using_0_subpath_1_with_target_2_6404": "Utilizzo di '{0}' sottotracciato '{1}' con destinazione '{2}'.",
  "Using_a_string_in_a_for_of_statement_is_only_supported_in_ECMAScript_5_and_higher_2494": "L'uso di una stringa in un'istruzione 'for...of' è supportato solo in ECMAScript 5 e versioni successive.",
  "Using_build_b_will_make_tsc_behave_more_like_a_build_orchestrator_than_a_compiler_This_is_used_to_tr_6915": "Se si usa --build, l'opzione -b modificherà il comportamento di tsc in modo che sia più simile a un agente di orchestrazione di compilazione che a un compilatore. Viene usata per attivare la compilazione di progetti compositi. Per altre informazioni, vedere {0}",
  "Using_compiler_options_of_project_reference_redirect_0_6215": "Using compiler options of project reference redirect '{0}'.",
  "VERSION_6036": "VERSIONE",
  "Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it_2560": "Il valore di tipo '{0}' non ha proprietà in comune con il tipo '{1}'. Si intendeva chiamarlo?",
  "Value_of_type_0_is_not_callable_Did_you_mean_to_include_new_2348": "Il valore di tipo '{0}' non è chiamabile. Si intendeva includere 'new'?",
  "Variable_0_implicitly_has_an_1_type_7005": "La variabile '{0}' contiene implicitamente un tipo '{1}'.",
  "Variable_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage_7043": "La variabile '{0}' include implicitamente un tipo '{1}', ma è possibile dedurre un tipo migliore dall'utilizzo.",
  "Variable_0_implicitly_has_type_1_in_some_locations_but_a_better_type_may_be_inferred_from_usage_7046": "La variabile '{0}' include implicitamente il tipo '{1}' in alcuni punti, ma è possibile dedurre un tipo migliore dall'utilizzo.",
  "Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined_7034": "La variabile '{0}' contiene implicitamente il tipo '{1}' in alcune posizioni in cui non è possibile determinarne il tipo.",
  "Variable_0_is_used_before_being_assigned_2454": "La variabile '{0}' viene usata prima dell'assegnazione.",
  "Variable_declaration_expected_1134": "È prevista la dichiarazione di variabile.",
  "Variable_declaration_list_cannot_be_empty_1123": "L'elenco delle dichiarazioni di variabile non può essere vuoto.",
  "Variable_declaration_not_allowed_at_this_location_1440": "Dichiarazione di variabile non consentita in questa posizione.",
  "Variadic_element_at_position_0_in_source_does_not_match_element_at_position_1_in_target_2625": "L'elemento variadic alla posizione {0} nell'origine non corrisponde all'elemento alla posizione {1} nella destinazione.",
  "Variance_annotations_are_only_supported_in_type_aliases_for_object_function_constructor_and_mapped_t_2637": "Le annotazioni di varianza sono supportate solo negli alias di tipo per oggetti, funzioni, costruttori e tipi mappati.",
  "Version_0_6029": "Versione {0}",
  "Visit_https_Colon_Slash_Slashaka_ms_Slashtsconfig_to_read_more_about_this_file_95110": "Per altre informazioni su questo file, visitare https://aka.ms/tsconfig",
  "WATCH_OPTIONS_6918": "OPZIONI DELL'ESPRESSIONE DI CONTROLLO",
  "Watch_and_Build_Modes_6250": "Modalità di espressione di controllo e compilazione",
  "Watch_input_files_6005": "Controlla i file di input.",
  "Watch_option_0_requires_a_value_of_type_1_5080": "Con l'opzione '{0}' dell'espressione di controllo è richiesto un valore di tipo {1}.",
  "We_can_only_write_a_type_for_0_by_adding_a_type_for_the_entire_parameter_here_2843": "È possibile solo scrivere un tipo per '{0}' aggiungendo qui un tipo per l'intero parametro.",
  "When_assigning_functions_check_to_ensure_parameters_and_the_return_values_are_subtype_compatible_6698": "Durante l'assegnazione di funzioni verifica che i parametri e i valori restituiti siano compatibili con il sottotipo.",
  "When_type_checking_take_into_account_null_and_undefined_6699": "Durante il controllo del tipo prende in considerazione 'null' e 'undefined'.",
  "Whether_to_keep_outdated_console_output_in_watch_mode_instead_of_clearing_the_screen_6191": "Indica se mantenere l'output della console obsoleto in modalità espressione di controllo invece di pulire lo schermo.",
  "Wrap_all_invalid_characters_in_an_expression_container_95109": "Eseguire il wrapping di tutti i caratteri non validi in un contenitore di espressioni",
  "Wrap_all_object_literal_with_parentheses_95116": "Racchiudere tra parentesi tutti i valori letterali di oggetto",
  "Wrap_all_unparented_JSX_in_JSX_fragment_95121": "Esegue il wrapping di JSX senza parentesi nel frammento JSX",
  "Wrap_in_JSX_fragment_95120": "Esegui il wrapping nel frammento JSX",
  "Wrap_invalid_character_in_an_expression_container_95108": "Eseguire il wrapping del carattere non valido in un contenitore di espressioni",
  "Wrap_the_following_body_with_parentheses_which_should_be_an_object_literal_95113": "Racchiudere tra parentesi il corpo seguente che deve essere un valore letterale di oggetto",
  "You_can_learn_about_all_of_the_compiler_options_at_0_6913": "Per informazioni su tutte le opzioni del compilatore, vedere {0}",
  "You_cannot_rename_a_module_via_a_global_import_8031": "Non è possibile rinominare un modulo tramite un'importazione globale.",
  "You_cannot_rename_elements_that_are_defined_in_a_node_modules_folder_8035": "Non è possibile rinominare gli elementi definiti in una cartella 'node_modules'.",
  "You_cannot_rename_elements_that_are_defined_in_another_node_modules_folder_8036": "Non è possibile rinominare gli elementi definiti in un'altra cartella 'node_modules'.",
  "You_cannot_rename_elements_that_are_defined_in_the_standard_TypeScript_library_8001": "Non è possibile rinominare elementi definiti nella libreria TypeScript standard.",
  "You_cannot_rename_this_element_8000": "Non è possibile rinominare questo elemento.",
  "_0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write__1329": "'{0}' accetta un numero troppo ridotto di argomenti da usare come espressione Decorator in questo punto. Si intendeva chiamarlo prima e scrivere '@{0}()'?",
  "_0_and_1_index_signatures_are_incompatible_2330": "Le firme dell'indice '{0}' e '{1}' non sono compatibili.",
  "_0_and_1_operations_cannot_be_mixed_without_parentheses_5076": "Non è possibile combinare le operazioni '{0}' e '{1}' senza parentesi.",
  "_0_are_specified_twice_The_attribute_named_0_will_be_overwritten_2710": "Gli attributi '{0}' sono stati specificati due volte. L'attribud re. if so, re-walk the contents of the
        // would-be class to re-translate any characters that
        // were passed through as-is
        // TODO: It would probably be faster to determine this
        // without a try/catch and a new RegExp, but it's tricky
        // to do safely.  For now, this is safe and works.
        var cs = pattern.substring(classStart + 1, i)
        try {
          RegExp('[' + cs + ']')
        } catch (er) {
          // not a valid class!
          var sp = this.parse(cs, SUBPARSE)
          re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
          hasMagic = hasMagic || sp[1]
          inClass = false
          continue
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
      continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
          && !(c === '^' && inClass)) {
          re += '\\'
        }

        re += c

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + '\\[' + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length)
    this.debug('setting tail', re, pl)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\'
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|'
    })

    this.debug('tail=%j\n   %s', tail, tail, pl, re)
    var t = pl.type === '*' ? star
      : pl.type === '?' ? qmark
      : '\\' + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + '\\(' + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += '\\\\'
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case '[': case '.': case '(': addPatternStart = true
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n]

    var nlBefore = re.slice(0, nl.reStart)
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
    var nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1
    var cleanAfter = nlAfter
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
    }
    nlAfter = cleanAfter

    var dollar = ''
    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$'
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
    re = newRe
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re
  }

  if (addPatternStart) {
    re = patternStart + re
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? 'i' : ''
  try {
    var regExp = new RegExp('^' + re + '$', flags)
  } catch (er) /* istanbul ignore next - should be impossible */ {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.')
  }

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) {
    this.regexp = false
    return this.regexp
  }
  var options = this.options

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  var flags = options.nocase ? 'i' : ''

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === 'string') ? regExpEscape(p)
      : p._src
    }).join('\\\/')
  }).join('|')

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$'

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$'

  try {
    this.regexp = new RegExp(re, flags)
  } catch (ex) /* istanbul ignore next - should be impossible */ {
    this.regexp = false
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {}
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (mm.options.nonull && !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = function match (f, partial) {
  if (typeof partial === 'undefined') partial = this.partial
  this.debug('match', f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options

  // windows: need to use /, not \
  if (path.sep !== '/') {
    f = f.split(path.sep).join('/')
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, 'split', f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, 'set', set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename
  var i
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i]
    if (filename) break
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i]
    var file = f
    if (options.matchBase && pattern.length === 1) {
      file = [filename]
    }
    var hit = this.matchOne(file, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options

  this.debug('matchOne',
    { 'this': this, file: file, pattern: pattern })

  this.debug('matchOne', file.length, pattern.length)

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi++, pi++) {
    this.debug('matchOne loop')
    var p = pattern[pi]
    var f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    /* istanbul ignore if */
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f])

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi
      var pr = pi + 1
      if (pr === pl) {
        this.debug('** at the end')
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' ||
            (!options.dot && file[fi].charAt(0) === '.')) return false
        }
        return true
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr]

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' ||
            (!options.dot && swallowee.charAt(0) === '.')) {
            this.debug('dot detected!', file, fr, pattern, pr)
            break
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue')
          fr++
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      /* istanbul ignore if */
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === 'string') {
      hit = f === p
      this.debug('string match', p, f, hit)
    } else {
      hit = f.match(p)
      this.debug('pattern match', p, f, hit)
    }

    if (!hit) return false
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
  } else /* istanbul ignore else */ if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    return (fi === fl - 1) && (file[fi] === '')
  }

  // should be unreachable.
  /* istanbul ignore next */
  throw new Error('wtf?')
}

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, '$1')
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
}
